h1. Compilador de KPascal

p>. Alcides Fonseca <br />
2006124656 <br />
amaf@student.dei.uc.pt


h2. Introdução

Hoje em dia o desenvolvimento de software é feito em linguagens de programação (de mais ou menos alto nível). A produtividade de um programador aumenta bastante quando não tem de se preocupar com aspectos físicos da máquina para que quer trabalhar, mas com o domínio do problema que quer resolver. O compilador é o que permite transformar essas linguagens de alto nível em código que vai ser executado no processador.

*Pascal* é uma linguagem de programação procedimental e imperativa. A linguagem é relativamente simples e promove uma estruturação do código, aspecto bastante importante na época em que foi publicada (1970). Os vários elementos da linguagem são comuns a muitas outras: a existência de if/then/elses, ciclos (while,repeat,for) e funções e procedimentos, que promovem o conceito DRY - _don't repeat yourself_.

h2. Arquitectura

Tradicionalmente os compiladores são escritos numa linguagem de baixo nível (normalmente C) que faz o parsing do programa input, analisa-o e converte-o para código máquina. Actualmente as linguagens estão cada vez mais próximas dos humanos, e este processo já não é exactamente deste modo. Surgiram virtual machines que correm um bytecode específico (os exemplos mais populares são o JavaVM ou .NET, mas linguagens como Python, Perl e Ruby têm uma pequena máquina virtual também), e já nem sempre são compiladores, mas sim interpretadores, visto que executam cada linha individualmente à medida que correm o input.

Neste projecto optei por não compilar para a linguagem C, mas para assembly (primeiro um bytecode intermeiário, um assembly de mais alto nível) que corre na plataforma x86 (testado no meu MacBook Intel), mas que também é portável para arquitecturas ARM. Essa geração recorre ao projecto LLVM (http://llvm.org/) e aos bindings para Python(http://mdevan.nfshost.com/llvm-py/).

Em relação ao parsing, segui o sugerido nas aulas, usando a dupla Lex e Yacc, mas escrevendo o código em Python, que permite uma maior preocupação com a estrutura do que C (principalmente por ter optado por uma arquitectura orientada a objectos).

A AST usada segue uma estrutura minimalista derivada do facto de Python ser uma linguagem dinâmica e que será detalhada na sua secção.

h2. Utilização

O compilador é um programa Python que é executado na linha de comandos. Para o correr é primeiro necessário ter algumas dependências:

* Python (2.5.4)
* PLY (http://pypi.python.org/pypi/ply/3.1)
* LLVM (http://llvm.org)
* LLVM-py (http://mdevan.nfshost.com/llvm-py/download.html)

Uma vez instaladas, bastará correr na linha de comandos nesta pasta: @./kpascal --help@

<pre>
	KPascal (master) >>> ./kpascal -help
	Usage: kpascal [options]

	Options:
	  -h, --help            show this help message and exit
	  -o <filename>, --out=<filename>
	                        write output to <filename>
	  -e, --emit            prints the bytecode to the screen
	  -g, --graph           shows the AST graph
	  -i, --instant         runs the result instead of saving
	
</pre>

h3. Ficheiro de input

Poderemos especificar o ficheiro de input chamando @./kpascal ficheiro.p@ que irá compilar esse ficheiro. Caso não receba nenhum parametro, irá ler do STDIN, o que permite receber código fonte a partir de outras ferramentas UNIX. Um exemplo seria @./kpascal < ficheiro.p@ ou @cat ficheiro.p | ./kpascal@.

h3. Ficheiro de ouput

Tal como o GCC, se não for especificado nenhum ficheiro binário resultante, será usado o nome "a.out". No entanto poderemos usar a flag -o para lhe dar o nome: @./kpascal -o ficheiro.out ficheiro.p@.

h3. Executar

Uma alternativa a compilar o programa, é apenas executa-lo. Este modo é um hibrido entre um compilador e um intepretador, visto que verifica o ficheiro todo antes de o executar, mas vai executando o código à medida que é gerado, ao contrário de um compilador tradicional. Este modo só é possível graças à utilização do LLVM e é uma mais valia em termos de tempo.

@./kpascal -i ficheiro.p@

h3. Mostrar bytecode

A nível de debugging é importante saber o que o compilador está a produzir. Ao chamar o programa @./kpascal -e ficheiro.p@ ele vai imprimir no ecrã uma representação humana do código assembly.

h3. Mostrar árvore AST.

Uma feature extra do compilador é o facto de gerar um gráfico com a AST. Para tal basta usar o comando @./kpascal -g ficheiro.p@ e ele vai gerar um ficheiro.p.png com o gráfico da árvore.

h2. Análise Sintática

Na análise sintática foi usado o Lex e Yacc, um conjunto de ferramentas que funcionam como um parser LALR, que permite o parsing de gramáticas livres de contexto com uma eficiência muito boa.

h3. Lex

O ficheiro @tokens.py@ contem a definição dos vários tokens da linguagem, através de expressões regulares. Estes passam pelos vários caracteres especiais (ponto e virgula, virgula, dois pontos, ponto, chavetas, sinais de soma, multiplicação, etc..., parentisis, tipos de variáveis (real, integer, string), os própios tipos, ifs, then, elses, funções, procedimentos, etc...).

No código existe um tuplo tokens que tem a listagem completa destes tokens.

h3. Yacc

A gramática que implementei é uma subgramática daquela referida no enunciado, com várias modificações para se arquear melhor ao problema mais concreto apresentado.


<pre>
program : header SEMICOLON block DOT
</pre><pre>
header : PROGRAM identifier
</pre><pre>
block : variable_declaration_part procedure_or_function statement_part
</pre><pre>
variable_declaration_part : VAR variable_declaration_list
	|
</pre><pre>
variable_declaration_list : variable_declaration variable_declaration_list
	| variable_declaration
</pre><pre>
variable_declaration : identifier COLON type SEMICOLON
</pre><pre>
procedure_or_function : proc_or_func_declaration SEMICOLON procedure_or_function
	|
</pre><pre>
proc_or_func_declaration : procedure_declaration
    | function_declaration
</pre><pre>
procedure_declaration : procedure_heading SEMICOLON block
</pre><pre>
procedure_heading : PROCEDURE identifier 
	| PROCEDURE identifier LPAREN parameter_list RPARE
</pre><pre>
function_declaration : function_heading SEMICOLON block
</pre><pre>
function_heading : FUNCTION type
 	| FUNCTION identifier COLON type
	| FUNCTION identifier LPAREN parameter_list RPAREN COLON type
	
</pre><pre>
parameter_list : parameter COMMA parameter_list
	| parameter
</pre><pre>
parameter : identifier COLON type
</pre><pre>
type : TREAL 
	| TINTEGER
	| TCHAR
	| TSTRING
</pre><pre>
statement_part : BEGIN statement_sequence END
</pre><pre>
statement_sequence : statement SEMICOLON statement_sequence
	| statement
</pre><pre>
statement : assignment_statement
	| statement_part
	| if_statement
	| while_statement
	| repeat_statement
	| for_statement
	| procedure_or_function_call
	|
</pre><pre>
procedure_or_function_call : identifier LPAREN param_list RPAREN
	| identifier
</pre><pre>
param_list : param_list COMMA param
	 | param
</pre><pre>
param : expression 
</pre><pre>
if_statement : IF expression THEN statement ELSE statement
	| IF expression THEN statement
</pre><pre>
while_statement : WHILE expression DO statement
</pre><pre>
repeat_statement : REPEAT statement UNTIL expression
</pre><pre>
for_statement : FOR assignment_statement TO expression DO statement
	| FOR assignment_statement DOWNTO expression DO statement
</pre><pre>
assignment_statement : identifier ASSIGNMENT expression
</pre><pre>
expression : expression and_or expression_m
	| expression_m
</pre><pre>
expression_m : expression_s
	| expression_m sign expression_s
</pre><pre>	
expression_s : element 
	| expression_s psign element
</pre><pre>
and_or : AND
	| OR
</pre><pre>	
psign : TIMES
	| DIVISION
</pre><pre>	
sign : PLUS
	| MINUS
	| DIV
	| MOD
	| EQ
	| NEQ
	| LT
	| LTE
	| GT
	| GTE
	
</pre><pre>
	
element : identifier
	| real
	| integer
	| string
	| char
	| LPAREN expression RPAREN
	| NOT element
	| function_call_inline
	
</pre><pre>
	
function_call_inline : identifier LPAREN param_list RPAREN
	
</pre>


h3. Geração da AST

A nossa AST é composta por nós. Cada nó pode ter um tipo, e um número infinito de argumentos de qualquer tipo. Aqui o dinamismo de Python torna a organização muito mais simples, do que a criação de inúmeras estruturas específicas como seria necessário em C.

Por cada regra (ou quase!) é gerado um nó de um certo tipo e com vários elementos. No caso do While, por exemplo, tem um filho que é a condição e outro para o corpo do while.


h2. Análise Semântica


h2. Geração de Código

